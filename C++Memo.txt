코딩 스탠다드

읽기전용 매개변수 상수 참조
출력결과용 매개변수는 포인터

assert로 null 체크

dynamic_cast가 c스타일 캐스팅에 비해 2~3배 느리다.
static_cast는 C스타일 캐스팅과 속도가 같다.

string이 char보다 3배 느리다.

2019. 04. 02
cppreference.com - 헤더 파일 어떤거 추가해야 될지 알고싶을때 확인

2019. 04. 03
RAII? 찾아보기
 - 2019. 04. 12 : C++에서 자주 쓰이는 idiom으로 자원의 안전한 사용을 위해 객체가 쓰이는 스코프를 벗어나면 자원을 해제해주는 기법이다
			https://blog.seulgi.kim/2014/01/raii.html

java의 vector[] list = new vector[10]은 포인터 10개 = vector** list = new Vector*[10]

malloc 과 new 의 차이는 생성자 호출의 차이 (알았던 거 같은데 까먹었었음)

클래스 초기화시 이니셜라이저로하면 좋은 점은 상수나 참조 변수도 초기화 가능하다라는 점

2019. 04. 06

연산자 오버로딩 () [] 어떻게 쓰는지 찾아보기

Zero-padding 또는 resizing

2019. 04. 11

정적 바인딩은 가상함수를 사용하지 않기 때문에 포인터의 함수를 호출하고 (컴파일중에 결정)
동적 바인딩은 가상함수를 사용하여 객체의 함수를 호출한다. (실행중에 결정)

가상 테이블은 객체마다 함수의 주소를 저장한 테이블
Unit* pUnit = new Player(); = 왜 이렇게 하는가

인터페이스는 함수만 있는 클래스

가상함수 매개변수가 다를때는?

2019. 04. 12

실수값 이진수는 어떨까?

static_cast는 이진수를 바꾸면서 캐스팅하지만 reinterpret_cast는 이진수를 바꾸지 않음
컴파일중에 캐스팅하기 때문에 성능저하가 없음

포인터를 비포인터로 바꿀때 reinterpret_cast를 씀
포인터의 오프셋을 저장한다? 신기하네

volatile ? 찾아보기

const_cast는 형 자체는 바꾸지 못하고 const 제거만 가능 volatile도 제거할 수 있음
써드파티 함수가 값을 변경하지 않는데 const가 없거나 const 값을 넣으면 작동하지 않을 때 사용한다.
내가 변경권한이 없는 외부 라이브러리를 호출할 때만 사용

dynamic_cast는 RTTI 켜야됨 (C++ 프로젝트에서는 RTTI를 끄는 것이 보통)
필요한 경우 보통 RTTI를 구현해서 사용함

2019. 04. 16

// ? 정적 멤버 함수가 다른 정적 멤버 함수와 멤버 변수에 접근할 수 있다?

// ? 함수 호출 오버 헤드

// ? 안티패턴

2019. 04. 18

try catch 예외처리하는 문법

예외 안전성 - 예외 상황이 나타났을 때 그 전 상황으로 돌아가는 것

// ? WCF

함수 이름에 예외처리시 반환값을 넣어서 함수 호출자에게 정보를 제공할 수 있다.

assert는 릴리즈에서 사라짐























 