코딩 스탠다드

읽기전용 매개변수 상수 참조
출력결과용 매개변수는 포인터

assert로 null 체크

dynamic_cast가 c스타일 캐스팅에 비해 2~3배 느리다.
static_cast는 C스타일 캐스팅과 속도가 같다.

string이 char보다 3배 느리다.

2019. 04. 02
cppreference.com - 헤더 파일 어떤거 추가해야 될지 알고싶을때 확인

2019. 04. 03
RAII? 찾아보기
 - 2019. 04. 12 : C++에서 자주 쓰이는 idiom으로 자원의 안전한 사용을 위해 객체가 쓰이는 스코프를 벗어나면 자원을 해제해주는 기법이다
			https://blog.seulgi.kim/2014/01/raii.html

java의 vector[] list = new vector[10]은 포인터 10개 = vector** list = new Vector*[10]

malloc 과 new 의 차이는 생성자 호출의 차이 (알았던 거 같은데 까먹었었음)

클래스 초기화시 이니셜라이저로하면 좋은 점은 상수나 참조 변수도 초기화 가능하다라는 점

2019. 04. 06

연산자 오버로딩 () [] 어떻게 쓰는지 찾아보기

Zero-padding 또는 resizing

2019. 04. 11

정적 바인딩은 가상함수를 사용하지 않기 때문에 포인터의 함수를 호출하고 (컴파일중에 결정)
동적 바인딩은 가상함수를 사용하여 객체의 함수를 호출한다. (실행중에 결정)

가상 테이블은 객체마다 함수의 주소를 저장한 테이블
Unit* pUnit = new Player(); = 왜 이렇게 하는가

인터페이스는 함수만 있는 클래스

// ? 가상함수 매개변수가 다를때는

2019. 04. 12

실수값 이진수는 어떨까?

static_cast는 이진수를 바꾸면서 캐스팅하지만 reinterpret_cast는 이진수를 바꾸지 않음
컴파일중에 캐스팅하기 때문에 성능저하가 없음

포인터를 비포인터로 바꿀때 reinterpret_cast를 씀
포인터의 오프셋을 저장한다? 신기하네

volatile 변수의 주소를 직접 접근하도록 하는 키워드 ( 최적화되지 않음)

const_cast는 형 자체는 바꾸지 못하고 const 제거만 가능 volatile도 제거할 수 있음
써드파티 함수가 값을 변경하지 않는데 const가 없거나 const 값을 넣으면 작동하지 않을 때 사용한다.
내가 변경권한이 없는 외부 라이브러리를 호출할 때만 사용

dynamic_cast는 RTTI 켜야됨 (C++ 프로젝트에서는 RTTI를 끄는 것이 보통)
필요한 경우 보통 RTTI를 구현해서 사용함

2019. 04. 16

// ? 정적 멤버 함수가 다른 정적 멤버 함수와 멤버 변수에 접근할 수 있다?

함수 호출 오버 헤드 - 생각하지 못한 연산이 추가되는 상황 

// ? 안티패턴

2019. 04. 18

try catch 예외처리하는 문법

예외 안전성 - 예외 상황이 나타났을 때 그 전 상황으로 돌아가는 것

// ? WCF

함수 이름에 예외처리시 반환값을 넣어서 함수 호출자에게 정보를 제공할 수 있다.

assert는 릴리즈에서 사라짐

2019. 04. 19

const vector의 반복자를 사용하려면 const_iterator를 사용해야 함.

map의 operator[]는 map의 value를 반환

개체가 없을 때 begin() end()는 end 반환

맵의 키에 클래스를 넣으려면 키값에 들어가는 클래스에 operator< 가 존재하거나 비교 클래스를 만들어서 맵을 만들때 3번째 인자로 넣어주면 된다.
operator< 만들때 뒤에 const 안붙이면 에러

맵의 탐색 속도는 list나 vector보다 빠름

2019. 04. 21

우선순위 큐

EA - EASTL 오픈소스, Epic games - tarray, tmap, tmultimap, tset
직접 컨테이너 개발해보기 - 더 심화해서

다형성 - 런타임시 어떤 클래스냐에 따라 행동이 달라지는 것 (이와 같이 답변할 수도 있겠다.)

// ? 블루프린트

템플릿을 인스턴스화할 때마다 컴파일러가 컴파일시 내부적으로 코드를 생성

enum의 값들은 상수에 별칭을 붙여주는 참조와 같은 방식이라서 클래스에 배열을 가질 때 배열의 갯수를 enum으로 정의한 값을 이용하면,
 define나 static const int로 해서 메모리가 할당되는 경우를 방지할 수 있다.

size_t = unsigned int

template<typename T, size_t N>으로 갯수 제한으로 사용한다.

// ! 소스 쓰는 것도 깃에 넣기





