코딩 스탠다드

읽기전용 매개변수 상수 참조
출력결과용 매개변수는 포인터

assert로 null 체크

dynamic_cast가 c스타일 캐스팅에 비해 2~3배 느리다.
static_cast는 C스타일 캐스팅과 속도가 같다.

string이 char보다 3배 느리다.

2019. 04. 02
cppreference.com - 헤더 파일 어떤거 추가해야 될지 알고싶을때 확인

2019. 04. 03
RAII? 찾아보기
 - 2019. 04. 12 : C++에서 자주 쓰이는 idiom으로 자원의 안전한 사용을 위해 객체가 쓰이는 스코프를 벗어나면 자원을 해제해주는 기법이다
			https://blog.seulgi.kim/2014/01/raii.html

java의 vector[] list = new vector[10]은 포인터 10개 = vector** list = new Vector*[10]

malloc 과 new 의 차이는 생성자 호출의 차이 (알았던 거 같은데 까먹었었음)

클래스 초기화시 이니셜라이저로하면 좋은 점은 상수나 참조 변수도 초기화 가능하다라는 점

2019. 04. 06

연산자 오버로딩 () [] 어떻게 쓰는지 찾아보기

Zero-padding 또는 resizing

2019. 04. 11

정적 바인딩은 가상함수를 사용하지 않기 때문에 포인터의 함수를 호출하고 (컴파일중에 결정)
동적 바인딩은 가상함수를 사용하여 객체의 함수를 호출한다. (실행중에 결정)

가상 테이블은 객체마다 함수의 주소를 저장한 테이블
// ? Unit* pUnit = new Player(); = 왜 이렇게 하는가
=> 생각했던 질문은 Player* pPlayer = new Player();를 하고 Unit* pUnit = new Player();이 어떤 게 다른 가 였지만 
	어셈블리 코드를 보면 같은 코드가 나온다. 그러므로 둘 다 맞는 표현이지만 결국 CUnit* 컨테이너에 넣을거라면 후자가 더 맞는 방식같다.

인터페이스는 함수만 있는 클래스

// ? 가상함수 매개변수가 다를때는
=> 매개 변수가 다르면 포인터의 클래스에 따라 함수 호출에 필요한 매개변수가 달라진다.

2019. 04. 12

실수값 이진수는 어떨까?
=> IEEE 754 를 기준으로 부호부 지수부 가수부로 이뤄진 값으로 되어 있음.
https://m.blog.naver.com/PostView.nhn?blogId=aka_handa&logNo=10081412293&categoryNo=38&proxyReferer=&proxyReferer
=https%3A%2F%2Fwww.google.co.kr%2F

static_cast는 이진수를 바꾸면서 캐스팅하지만 reinterpret_cast는 이진수를 바꾸지 않음
컴파일중에 캐스팅하기 때문에 성능저하가 없음

포인터를 비포인터로 바꿀때 reinterpret_cast를 씀
포인터의 오프셋을 저장한다? 신기하네

volatile 변수의 주소를 직접 접근하도록 하는 키워드 (최적화되지 않음)

const_cast는 형 자체는 바꾸지 못하고 const 제거만 가능 volatile도 제거할 수 있음
써드파티 함수가 값을 변경하지 않는데 const가 없거나 const 값을 넣으면 작동하지 않을 때 사용한다.
내가 변경권한이 없는 외부 라이브러리를 호출할 때만 사용

dynamic_cast는 RTTI 켜야됨 (C++ 프로젝트에서는 RTTI를 끄는 것이 보통)
필요한 경우 보통 RTTI를 구현해서 사용함

2019. 04. 16

// ? 정적 멤버 함수가 다른 정적 멤버 함수와 멤버 변수에 접근할 수 있다?
=> 맞는 말인데 헷갈린 거 같음

함수 호출 오버 헤드 - 생각하지 못한 연산이 추가되는 상황 

// ? 안티패턴
=> 자주 사용되는 패턴이지만 비효율적이거나 비생산적인 패턴
http://egloos.zum.com/kwon37xi/v/4634829
UML ( Unified Modeling Language)
+ 전략패턴 - 클래스가 상속받은 함수를 재정의하는 게 아니라 캡슐화한 클래스를 상속하여 여러 함수로 재정의 되어 있는 인터페이스 객체를 
가지고 있다가 필요한 경우 함수 자체를 바꾸는 게 아닌 객체를 바꾸는 방식

2019. 04. 18

try catch 예외처리하는 문법

예외 안전성 - 예외 상황이 나타났을 때 그 전 상황으로 돌아가는 것

// ? WCF
=> 윈도우 커뮤니케이션 파운데이션 - 통신 관련 프로그램? 닷넷

함수 이름에 예외처리시 반환값을 넣어서 함수 호출자에게 정보를 제공할 수 있다.

assert는 릴리즈에서 사라짐

2019. 04. 19

const vector의 반복자를 사용하려면 const_iterator를 사용해야 함.

map의 operator[]는 map의 value를 반환

개체가 없을 때 begin() end()는 end 반환

맵의 키에 클래스를 넣으려면 키값에 들어가는 클래스에 operator< 가 존재하거나 비교 클래스를 만들어서 맵을 만들때 3번째 인자로 넣어주면 된다.
operator< 만들때 뒤에 const 안붙이면 에러

맵의 탐색 속도는 list나 vector보다 빠름

2019. 04. 21

우선순위 큐

EA - EASTL 오픈소스, Epic games - tarray, tmap, tmultimap, tset
직접 컨테이너 개발해보기 - 더 심화해서

다형성 - 런타임시 어떤 클래스냐에 따라 행동이 달라지는 것 (이와 같이 답변할 수도 있겠다.)

// ? 블루프린트

템플릿을 인스턴스화할 때마다 컴파일러가 컴파일시 내부적으로 코드를 생성

enum의 값들은 상수에 별칭을 붙여주는 참조와 같은 방식이라서 클래스에 배열을 가질 때 배열의 갯수를 enum으로 정의한 값을 이용하면,
 define나 static const int로 해서 메모리가 할당되는 경우를 방지할 수 있다.

size_t = unsigned int

template<typename T, size_t N>으로 갯수 제한으로 사용한다.

// ! 소스 쓰는 것도 깃에 넣기
=> 추가 함

2019. 04. 23

// ! ++a a++ 어셈블리로 확인해보기
=> 전위연산자보다 후위연산자가 mov 를 2번 더 사용한다. 결과적으로 느림

// ? 템플릿 다형성?
=> 정적 다형성으로 구현할 수 있다.
템플릿 함수를 만들고 그 함수를 사용하는 객체가 같은 함수나 변수를 가지고 있는 상태에서 템플릿 함수를 사용하면 다형성이 된다.
https://wikidocs.net/490

// ? CRTP 템플릿 패턴
가상함수를 사용하지 않고 템플릿 부모 클래스로 만들어 상속할 때 넘겨준다. 호출 함수를 만들어 그 함수에서 static_cast를 통해 자식 객체의
함수가 호출되도록 하는 패턴
https://supark7.tistory.com/entry/31-CRTP-Curiously-Recurring-Template-Pattern

auto 쓸때 const, *, & 할 경우 명시적으로 써서 가독성을 좋게 한다.

평소와 같이 auto는 자제한다.

auto를 사용할만한 곳
1. 반복자를 대신해서 auto 사용
ex) for(vector<int>::iterator iter = v.begin(); iter != v.end(); ++iter)
     for(auto iter = v.begin(); iter != v.end(); ++iter)
2. 템플릿 형을 받을 때
ex) MyArray<int*> arr = new MyArray<int*>(10);
     auto arr = new MyArray<int*>(10);

// ! for문 stl::end() 에 있을 때랑 이미 받은 반복자를 비교하는 거 실험
=> for문 돌 때 마다 계속 end함수를 호출하기 때문에 더 느려짐

// ? assert를 쓰면 호출스택이 이상해진다?

static_assert
컴파일중에 정적으로 가정이 맞는지 판단하여 틀린 경우 에러를 반환하는 방식 

사용처 예
1. 구조체의 크기가 맞는지 확인하는 것 - 구조체의 정보를 읽어오는데 구조체의 크기가 달라지면 불러들이는 값이 다르기 때문에
문제가 생김으로 기존의 구조체 크기와 비교해 본다.
2. 클래스의 버전이나 기능의 버전이 몇 이상이거나 이하만 제공할 경우 체크해볼 수 있다.
3. 배열의 길이를 체크할 때

// ?  explicit 찾아보기
=> 암시적 형변환 막는 키워드로 생성자에 많이 사용함.

default는 디폴트 함수를 자동으로 코드로 만들어주고, delete는 디폴트 함수를 지워준다.

final 키워드를 사용하면 해당 클래스를 상속을 막거나 가상 함수의 오버라이딩을 막을 수 있다.

override 키워드는 가상 함수가 부모에게 상속 받은 가상 함수인지 확인해서 컴파일 에러로 알려준다.









